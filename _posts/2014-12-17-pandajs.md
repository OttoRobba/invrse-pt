---
layout:     post
title:      PandaJS, uma engine HTML5 modular
date:       2014-12-17 20:00:00
permalink:  pandajs-review
categories: 
    - review
    - game framework
    - pandajs
comments:   true
image: pandajs_review
---

Hoje conheceremos a <a href="http://www.pandajs.net/" target="_blank">PandaJS</a>, uma engine para jogos HTML5 desenvolvida por <a href="https://github.com/ekelokorpi" target="_blank">Eemeli Kelokorpi</a>. Eu vou aproveitar e compará-la com o Phaser, atualmente o frameowkr mais popular para jogos em HTML5.

###A mentalidade do Panda

Antes de começar a usar a engine, vamos entender como ela funciona. A premissa da ferramenta é que você cria blocos menores e reutilizáveis de código (chamados módulos) e os requere conforme for preciso. Um módulo é criado assim:

{% highlight javascript %}
game.module( //Usamos esse callback com um argumento de string
    'game.assets' //o arquivo se chama assets e está na pasta game
)
//Tudo que o módulo faz vai dentro da função que é passada para a callback .body
.body(function () {
    //Como exemplo, estou carregando algumas imagens
    game.addAsset('paddle.png');
    game.addAsset('game_logo.png');
});
{% endhighlight %}

No arquivo main.js, nós requeremos o módulo que criamos acima:

{% highlight javascript %}
game.module(
    'game.main' //Esse é o primeiro arquivo chamado pela engine
)
.require(
    'game.assets' //Isso permite usar qualquer coisa do arquivo assets.js
)
.body(function () {
    game.createScene('Main', {
        backgroundColor: 0xffaa00
    });
});
{% endhighlight %}

Como dá para ver, é um tanto diferente. É um padrão de desenvolvimento de jogos bastante eficaz dentro do paradigma de orientação por objeto. Eu honestamente acredito que para times e novatos, ser estrito assim evitar sérios problemas.

###Entidades & Classes

PandaJS usa um sistema de classes baseado no trabalho do <a href="http://ejohn.org/blog/simple-javascript-inheritance/" target="_blank">John Resig</a>. Isso signifca que você pode criar e extender classes para reusar certas funcionabilidades.

Por exemplo, vamos supor que estamos fazendo um jogo de Pong, usando uma das imagens que carregamos anteriormente no assets.js, nós poderíamos fazer uma classe "Paddle" assim:

{% highlight javascript %}
game.module(
    //Eu salvei esse arquivo na pasta entities
    'game.entities.paddle'
)
.body(function() {
game.createClass('Paddle', {
    //A função init é chamada quando um objeto é criado
    //Você pode passar os argumentos que quiser
    init: function(x, y) {
        this.sprite = new game.Sprite('paddle.png');
        
        //Como PandaJS usa PixiJS, 
        //você tem acesso aos métodos e propriedades do último
        this.sprite.position.x = x;
        this.sprite.position.y = y;
        this.sprite.anchor.set(0.5, 0.5);
        
        //Por fim, adicionamos o sprite ao stage para que ele seja renderizado
        game.scene.stage.addChild(this.sprite);
    }
});

});
{% endhighlight %}

Nada mal né? De volta no nosso main.js, poderíamos fazer a 'paddle' assim:

{% highlight javascript %}
game.module(
    'game.main'
)
.require(
    'game.assets',
    'game.entities.paddle',
)
.body(function () {
    game.createScene('Main', {
        backgroundColor: 0xffaa00,
        init: function () {
            var paddle = new game.Paddle(200,200);
        }
    });
});
{% endhighlight %}

Bem simples e reutilizável!

###Performance

Apesar de ser elegant, o método que Resig usa para criar classes consome bastante memória, o que ocasiona mais chamadas ao coletor de lixo do JavaScript. Nós não queremos isso. PandaJS diminui esse baque com o sistema de pooling que, ao invés de criar novas entidades, permite que elas sejam reutilizadas.

Num jogo de tiro, por exemplo, você pode começar com umas 100 balas pré-criadas. Conforme elas são disparadas, atingem algo e saem do jogo, elas simplesmente são movidas pra fora da tela e adicionadas pra uma lista de entidades desativadas. Quando você atirar de novo uma entidade desativada será reativada e reposicionada. Bacana né?

Quanto a renderização, PandaJS usa o PixiJS então pode contar com uma performance excelente!

*Breve nota para usuários Firefox no Linux*: PandaJS pode não funcionar corretamente devido a um bug com o renderizador (Cairo) do Firefox.. <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=561361" target="_blank">Se você usar o Skia, deve funcionar sem problemas</a>.


###Modularidade & plugins

É da natureza da ferramenta ser pequena. PandaJS consegue fazer bastante coisa por si só mas, para outras tantas, você pode usar plugins - eles são, essencialmente, módulos especiais que podem ser compartilhados e adicionados em qualquer jogo. Você pode adicionar um sistema de física mais robusto, tal como Box2D ou P2 simplesmente puxando-os e requerendo-os igual fizemos com o assets.js.

![Modular & pluggable]({{site.baseurl}}/assets/pandajs/modular.png)

###Configuração

Você pode determinar o tamanho do jogo e outras opções de qualquer uma das classes do PandaJS num arquivo especial chamado config.js, simplificando as coisas. Um exemplo de um arquivo config:

{% highlight javascript %}
pandaConfig = {
    name: 'MyPandaGame',
    version: '0.0.0',
    sitelock: 'invrse.co',

    system: {
        width: 640,
        height: 480,
        scaleToFit: true,
        webGL: true,
		hires: 4 
    }
};
{% endhighlight %}

Isso separa o código que cuida do jogo de coisas como resolução, sitelock e afins, limpando seu código e facilitando futuras modificações.

###Documentação

O código fonte é bem fácil de ler, o que é ótimo já que não há tanta documentação para a ferramenta quanto eu acredito ser ideal.

Claro, é uma engine bem nova e o criador fez um ótimo esforço em fornecer uma boa fundação. Entre a <a href="http://www.pandajs.net/cheatsheet/" target="_blank">cola</a>, a <a href="http://www.pandajs.net/docs/" target="_blank">documentação</a> e essa análise você provavelmente consegue começar a fazer jogos básicos com a engine.

Acredito que, com o tempo, mais material sobre a engine será produzido e a barreira de entrada diminua ainda mais.

###Automação

Uma coisa muito legal do PandaJS é que ela inclui ferramentas de automação! Claro, você poderia ir e baixar a engine do GitHub e afins mas o melhor método é instalando o Pandatool com o npm.

        npm install -g pandatool
        
Pra criar um projeto novo, via linha de comando, é fácil assim óh:

        panda install
        
E você pode compilar para distribuição assim:

        panda build
        
Eu, pessoalmente, acho isso fantástico. Você também pode fazer coisas como atualizar a versão da engine e checar seu código por falhas. Muito legal!

###O futuro da PandaJS

Que a ferramenta vai continuar melhorando é claro mas uma coisa muito legal são os plugins que estão surgindo, feitos pela comunidade e/ou pelo Eemeli. Box2D, P2, AABB, IA básica... tem muito potencial aqui.

As jóias da coroa estão, sem dúvida, no editor que o Eemeli está desenvolvendo chamado de "Bamboo".

<iframe width="100%" height="435" src="//www.youtube.com/embed/-le77lF0I3U?rel=0&amp;vq=hd1440" frameborder="0" allowfullscreen></iframe>


###Comparação com Phaser

Eu escolhi o [Phaser]({{site.baseurl}}/phaser-review) para comparação com base em sua popularidade e no fato que os dois usam PixiJS, tem pooling, partículas, tweening e afins.

Enquanto PandaJS é construído na ideia de modulariedade, Phaser é feito com base na conveniência - você escreve poucas linhas e pronto. Não precisa, por exemplo, lembrar de adicionar sprites ao stage e tem três opções de engine de física logo de partida.

Sendo bem completa, não-modular e cobrindo vários cenários diferentes significa que o código do Phaser é monolítico, pesando em 2mb sem minificação. Isso significa que demora mais para atravessar e entender o que e como as coisas acontecem. PandaJS é menos da metade disso com seus 700kbytes.

Phaser é uma engine sem opiniões em como você trabalha com ela - não há um sistema de automação e você facilmente re-usa o que tiver. Gulp, Grunt, o que for.

Phaser não tem um editor oficial (ainda, pelo menos) e por mais que existam esforços da comunidade (tal como o MightyEditor), eles forçam pilhas de código que modificam o modo de trabalhar com a engine. Bamboo está sendo desenvolvido com uma integração mais limpa, sem grandes gambiarras em torno da engine.

###Concluindo

Eu honestamente acredito que a força da PandaJS está na sua modulariedade, na pequena base de código, no padrão de design e no sistema de automação embutido. É fácil de entender e sinto como sendo uma solução bastante completa.

Acredito que, com o tempo, PandaJS vai se provar como uma das melhores engines para desenvolvimento em HTML5.